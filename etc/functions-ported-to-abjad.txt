Functions migrated from baca/util.py to Abjad:


   util.bunch(l, s, cycle = True)
   ==>
   seqtools.group_by_weights(l, s, fill = 'exact', cyclic = False, overhang = False)


   util.caulk(l, directives)
   ==>
   cary.transforms.take_sublist_element_absolute_values(l, directives)


   util.chunk(ll, s)
   ==>
   seqtools.partition_by_weights(l, s, overhang = overhang, cyclic = cyclic)


   util.circumrotate(l, inner, outer)
   ==>
   util.rotate_nested(l, inner, outer)


   util.clump(w, action = 'in place')
   ==>
   [list(seqtools.sum_by_sign(x, sign = [-1])) for x in w]


   util.convolve(l, s, action = 'in place')
   ==>
   util.increase_sublist_end_elements(l, s) 

   
   util.corrugate(l, signs = 'positives')
   ==>
   util.replace_nested_elements_with_unary_subruns(l)


   util.cycle(outer, inner, l, flattened = True)
   ==>
   util.helianthate(l, outer, inner, flattened = True)


   util.draw(l, s, history = False)
   ==>
   music.repeat_subruns_cyclic(notes, subrun_indicators, history = False)


   util.flamingo(l, s, period = None)
   ==>
   seqtools.negate_elements_at_indices(l, indices, period = None)


   util.flip(l, s, action = 'in place')
   ==>
   cary.transforms.flip_sublist_element_signs(l, s)


   util.glom(l)
   ==>
   util.clump(l)


   util.intize(l, action = 'in place')
   ==>
   l = [int(x) if int(x) == x else x for x in l]
   

   util.lump(w, action = 'in place')
   ==>
   [list(seqtools.sum_by_sign(x, sign = [1])) for x in w]


   util.mapInto(M, n)
   ==>
   pitchtools.send_pitch_number_to_octave(pitch_number, mapping)


   util.negate(l, s, action = 'in place')
   ==>
   cary.transforms.negate_one_element_sublists_cyclic(l, specification)


   util.ones(l, action = 'in place')
   ==>
   use [[1] * x for x in l] instead
   
   
   util.partition(l, s, mode = 'length', overhang = False, cyclic = False)
   ==>
   seqtools.partition_by_counts(l, counts, overhang = False, cyclic = False)
   seqtools.partition_by_weights(l, counts, overhang = False, cyclic = False)
   ==>
   seqtools.partition_by_lengths(l, counts, overhang = False, cyclic = False)

   
   util.permIter(seq)
   ==>
   seqtools.permtutations(l)

   
   util.permute(l, s, action = 'in place')
   ==>
   pitchtools.permute_by_row(pitches, row)


   util.pick( )
   ==>
   use %


   util.picket(l, ins, overhang = (0, 0))
   ==>
   seqtools.insert_slice_cyclic(l, s, overhang = (0, 0))

   
   util.piles(ll)
   ==> 
   unused: cumulative sums of absolute values of elements in ll.


   util.pleat(l, n)
   ==>
   seqtools.repeat_elements_to_length(l, n)
   ==>
   seqtools.repeat_elements_to_count(l, count)


   util.plough(w, s, cur = 0, action = 'in place')
   ==>
   s = period_s
   s = seqtools.true_indices(s)
   w_part_counts = [len(x) for x in w]
   w = seqtools.flatten(w)
   w = seqtools.negate_elements_at_indices(w, s, period = period_s)
   w = seqtools.partition_by_counts(w, w_part_counts)


   util.positivize(w)
   ==>
   l = [abs(x) for x in l]
   

   util.project(l, spec, history = False)
   ==>
   pitchtools.insert_transposed_pc_subruns(notes, subrun_indicators, history = False)


   util.read(l, start, length)
   ==>
   seqtools.repeat_to_length(l, length, start_index = start)


   util.recombine(target, s, insert, t, loci)
   ==>
   partitioned_target = seqtools.partition_by_counts(target, s)
   partitioned_insert = seqtools.partition_by_counts(insert, t)
   periodic_insert = (partitioned_insert, len(partitioned_insert)
   result = seqtools.replace_elements_cyclic(
      partition_target, (loci, None), periodic_insert)
   result = seqtools.flatten(result)


   util.replace(l, indices, material)
   ==>
   seqtools.overwrite_elements_at(l, indices, material)
   ==>
   seqtools.replace_elements_cyclic(l, indices, material)


   util.resegment(w, s, max = False, overhang = True)
   ==>
   seqtools.partition_by_weights_not_less_than(seqtools.flatten(w), s, cyclic = True, 
      overhang = overhang)
   The max keyword never worked correctly.


   util.ripple(l, [(anchor, (length, total_appearances)), ...])
   ie, util.ripple(l, [(i, (length, n), ...])
   ==>
   seqtools.repeat_subruns_cyclic(l, [(achor, length, new_appearances), ...])
   ie, seqtools.repeat_subruns_cyclic(l, [(i, length, n - 1), ...])
   ==>
   seqtools.repeat_subruns_to_count( )


   util.rout(l, s, cur = 0, recurse = False)
   ==>
   period_s = len(s)
   s_true_indices = seqtools.true_indices(s)
   seqtools.negate_elements_at_indices_absolutely(l, s_true_indices, period_s)


   util.scan(l)
   ==>
   for i, leaf in enumerate(l)
   next, prev, = leaf.next, leaf.prev 


   util.segment(l, s, cycle = False)
   ==>
   seqtools.partition_by_weights_not_less_than(l, s, cyclic = False, overhang = False)


   util.segment(l, s, cycle = 'knife')
   ==>
   seqtools.partition_by_weights_not_less_than(l, s, cyclic = True, overhang = False)


   util.segment(l, s, cycle = 'knife')
   ==>
   l = seqtools.repeat_list_to_weight(l, sum(s), remainder = 'more')
   seqtools.partition_by_weights_not_less_than(l, s, cyclic = True, overhang = False)


   util.smear(l, s)
   ==>
   seqtools.overwrite_slices_at(l, pairs)


   util.smelt(ll)
   ==>
   lidercfeny.transforms.lengths_to_joined_positive_counts(l)


   util.snip(l, weight, i) 
   ==> 
   seqtools.remove_weighted_subrun_at(l, weight, i)


   util.spot(l, s, positions, action = 'in place')
   ==>
   seqtools.increase_at_indices(l, addenda, indices)


   util.unfive(l, target = 'negative')
   ==>
   util.partition_nested_into_inward_pointing_parts(l, target = 'negative')


   util.untie(expr, signs = 'all positive')
   ==>
   util.partition_nested_into_canonic_parts(expr, direction = 'big-endian')


   util.within( )
   ==>
   use %
