*Chunk specification.* Define chunk specification H equal to the 4-tuple (S, T, D, P),
with score template S, tempo specification T, duration specification D, 
and unordered set of zero or more population specifications P. 

*Score template.* Define score template S equal to any prebuilt empty voiced score S.

*Tempo specification.* Define tempo specification T equal to any absolute 
or relative tempo specification. Tempo specification T is optional.
The system currently affords relative tempo specification only with reference to another chunk exactly.
(All sorts of other relative tempo specification scenarios are possible. We leave these for later.)

*Duration specification.* Define duration specification D equal to any written duration,
any duration in seconds or any meter specification M. Tempo must be resolvable where
D equals a duration in seconds.

*Meter specification.* Define meter specification M equal to an ordered list of one or more meters.
The system currently models meter specification as an (optional) chunk attribute.
Eventually, the system will also model meter specification as a staff group and staff attribute.
This is implies the following: first, chunks may be unmetered.
Second, the system models measures as 'backgrounding' notes, rests, chords and tuplets 
rather than containing notes, rests, chords and tuplets.
Third, the contents of metered chunks is expected to match the sum of chunk meters.
Fourth, the metering of staff chunks will eventually be allowed to differ.
Fifth, metering will eventually 'cascade' down the score hierarchy similarly 
to typographic attributes and other settings.
Metering may be specified absolutely, relatively or with reference to a stateful server.
All cases of relative metering specification are based on reference to the metering of another chunk.
The current implementation of the system affords relative meter specification of chunk H
as equal to meters i through j of chunk K, allowing for positive, negative and empty values of i, j.
(Many variations are possible but all are left for later implementation.)
Statal meter specification assumes a hierarchical statal server that is duration-aware.
(Many variations are possible but only next-durative values will implement now.)

*Population specifications.* Define population specification p equal the pair (s, h),
with selection s and handler h.

                                    * * *

*Interpretation.* Interpretation follows specification.
Chunk interpretation comprises two parts.
Part one creates an in-memory list of chunks and an in-memory list of relative references.
Part two resolves relative references and alerts on cyclic references.
Chunk interpretation returns a list of raw chunks and a list of interpreted chunks.
Any chunk specification may be interpreted singly or in score-sequence.
Chunk specifications interpreted singly may not be able to resolve relative references.
(Relative references are defined as specifications given in terms of other specifications.)
Raw chunks may or may not notate; interpreted chunks always notate completely.
The purpose of interpretation is to make all chunks notatable.

                                    * * *

*Selections.* We define a selection equal to an ordered list of zero or more component selections.
We define a component selection equal to the triple of a score component together with
a start indicator and a stop indicator. We say that start and stop indicators are both types
of time indicator and we define the notion of a time indicator with respect to component t.
Consider the score s that houses t. We say that a time indicator is the start time or stop time
of any component in s (including t itself) or else any offset value or absolute time value
within the duration of s. Zero and positive infinity are both valid time indicators, 
although negative numbers are not.

*Selection iteration.* The component selections that comprise any given selection are always ordered.
But this order requirement says nothing about the order in which the sum total of components
contained in the selection is to be iterated. This is by design: any iterator may be used to
iterate the components of any selection.

*Partitioning time.* There appears to be a closed but tricky set of time partition functions.
(1.0) as an unrounded proportion of chunk duration; 
(1.1a) as a proportion of chunk duration rounded to the start of the current measure;
(1.1b) as a proportion of chunk duration rounded to the stop of the current measure;
(1.2a) as a proportion of chunk duration rounded to the start of the current leaf;
(1.2b) as a proportion of chunk duration rounded to the stop of the current leaf;
(2.0) as an unrounded amount of absolute time;
(2.1a) as an amount of absolute time rounded to the start of the current measure;
(2.1b) as an amount of absolute time rounded to the stop of the current measure;
(2.2a) as an amount of absolute time rounded to the start of the current leaf;
(2.2b) as an amount of absolute time rounded to the stop of the current leaf.
Constraints apply to these divisional methods:
measures of absolute time enter availability only after tempo specification;
measure-rounding enters availability only after measure determination;
leaf-rounding enters availability only after leaf determination.

*Hierarchical statal servers.* Valid requests to a hierarchical statal server include:
(1) get node at position; (2) get next n nodes at level; (3) get next n complete nodes at level.

                                    * * *

*Rhythm-first specification.* We create rhythm specification ρ of voice v in chunk h.
Partition the duration of v into n time-parts, with 1 <= n, according to any of the
time partitioning functions detailed above; call n the 'part-length' of ρ.
Decide whether time-part 0 continues the last time-part of the previous chunk;
decide whether time-part n - 1 extends beyond the bondary of the current chunk;
where the first condition obtains, we refer to ρ as left-inapplicable (otherwise left-applicable);
where the second condition obtains, we refer to ρ as right-inapplicable (otherwise right-applicable);
where ρ is both left- and right-inapplicable and the part-length of ρ == 1, we call ρ inapplicable.
Collect the m applicable time-parts in ρ, with m <= n;  call m the 'applicable part-length' of ρ.
For each applicable time-parts p in ρ, specify the rhythmic divisions of p and then the rhythms of p.
Rhythmic divisions are always specified by the combination of a rhythmic division handler
together with one (or rarely more) input parameters passed to the rhythmic division handler.
(A straightforward example is a rhythmic division handler that divides the duration of p
into consecutive eighth notes, with any fractional duration positioned at the end of p.)
Rhythms are always specified by the combination of a rhythm handler together with zero
or more input parameters passed to the rhythm handler. (An example is a rhythm handler 
that fills the rhythmic divisions of p with exactly 5 attack points.)
To summarize: rhythm specification of v is complete after the specification of a 
division handler / rhythm handler pair for each applicable part in any time-partition of v.

*Pitch-first specification.* Pitch-class material may be specified absolutely, relatively
or with reference to a stateful server.
Absolute pitch-class specification provides some pitch-class structure explicitly; 
this may be a list of zero or more pitch-classes or else a more complex aggregate of pitch-classes.
Relative pitch-class specification works with reference to a selection; see the section of selections.
Statal specification of pitch-classes proceeds with the help of a pitch-class server.
All pitch-class servers are taken to be cyclic trees. So the valid things that can
be requested of a pitch-class server are all those things that can be requested 
of a hierarchical statal server; see the section on hierarchical statal servers.
    
*Voice-local specification: secondary parameters.*
The user may specify an arbitrary number of secondary parameters.
Thes include articulation, dynamics and various types of spanner.
The specification of secondary parameters proceeds according to the specification
of a selection followed by the specification of a handler (sometimes with handler input).
(Example: specify that the entire chunk be selected; then specify an articulation handler 
that applies a staccato dot to every note iterated in depth-first order.
Example: specify that the duration of the violin voice is to be partitioned into halves
and that the second half is to be selected; then specify a dynamic handler 
that applies haipins to runs of notes and chords in the selection.
Example: specify that the last note or chord in the percussion voice is to be selected;
then specify an articulation handler that applies a marcato to any note or chord selected.)

*Division specification.* Division specification admits a great variety of configuration
than time signature specification. Division specifications are structured the same way
as every other type of specification: that is, as the pair of a target token
together with a source. Further, division specification target tokens take the same form 
as every type of target token: that is, as the triple of a segment name, a list of zero
or more context names, and an optional (horizontal) scope that acts as type of filter
on all contexts implicated in the selection. Two areas of this model of division specification
require elaboration. The first of these relates to the logical limits attaching to the targets
of division specification. The second must detail the number and type of sources that
division specification admits.

*Targets of division specification.* Suppose segment T comprises time signatures 
[(2, 8), (2, 8), (2, 8)], with total duration (6, 8). The act of specifying divisions
for any of the contexts in T is equivalent to partitioning the (6, 8) of total time
any of the contexts in T consumes. The simplest case obtains in any manifest list of
durations. It is possible, for example, the specify the divisions of the violin 1 voice
in T manifestly equal to the durations [(3, 8), (3, 8)]; such a setting applies to the
entire duration of the violin 1 voice in T and implies a target selection equal to
the entirety of the violin 1 voice in T. It is more likely to specify the divisions of
the violin 1 voice in T in terms of a callable. (We define a callable equal to any function,
method or callable class with signature that allows, at minimum, for the input of a list of 
durations.) It is, therefore, possible to set the divisions of the violin 1
voice in T equal to the output of callable foo(). In the case that the entirety of the
duration of the violin 1 voice in T is set equal to the output of callable foo(), the
duration list [(2, 8), (2, 8), (2, 8)] will be passed as input to foo(). It is also possible
to set the divisions of only the first two measures of the violin 1 voice in T equal to
the output of foo() while setting the divisions of the last measure of the violin 1 voice in T
equal to the output bar(); in this case, the duration list [(2, 8), (2, 8)] will be 
passed as input to foo() and the duration list [(2, 8)] will be passed as input to bar().
It is also possible to specify the divisions of duration-partitioned parts of the violin 1
voice in T without reference to the time signatures of T at all. For example, it is possible
to set the divisions of the first [(3, 8)] of the violin 1 voice in T equal to the output of foo()
and the divisions of the last [(3, 8)] of the of the violin 1 voice in T equal to the output of bar(),
in which case the duration list [(3, 8)] will be passed as input to foo() and the duration
list [(3, 8)] will be passed as input to bar(). It is further possible to set the divisions of
the first [(3, 16), (3, 16)] of the violin 1 voice in T equal to the output of foo() and the
divisions of the last [(1, 8), (1, 8), (1, 8)] of the violin 1 voice in T equal to the output
of bar(), in which case the duration list [(3, 16), (3, 16)] will be passed as input to foo()
and the duration list [(1, 8), (1, 8), (1, 8)] will be passed as input to bar().

Division specifications must not apply cumulatively for any given context in T. That is, there 
must not be more than one division specification for the violin 1 voice in T. Division
specification Tn for the violin 1 voice in T may specify as complex partitioned target of
the duration of the violin 1 voice in T as desired; but Tn must then specify sources
(in the form of either manifest values or callables) for each of the parts in the target
selection of Tn. The specification interface might look like this:

selection = segment.select_measures(segment, part=[1, 1, 1])
selection[0](foo)
selection[1](bar)
selection[2](foo)
segment.set_divisions(selection)

Or the specification interface might allow for simple setting cascades like this:

selection = segment.select_measures(segment, part=[1, 1, 1])
selection(foo)
selection[1](bar)
segment.set_divisions(selection)

We have so far allowed for division specification sources set equal to manifest values or to
callables. We have not allow for division specification sources set equal to requests 
against statal servers; divisions specification sources set equal to statal server requests
seem less likely and a good candidate for omission in this round of implementation.

A third case arises in the possibility of settting a division specification source
equal to a callable specified elsewhere in the score.

A fourth case arises in the possibility of setting a division specification source
equal to a (potentially indefinitely long) series of actual divisions read (forward or
backward) from any other division elsewhere in the score.

A fifth case arises in the possibility of setting a division specification source to
a finite series of divisions (to be read cyclically either forward or backward) from any
other context elsewhere in the score.

We leave the current implementation confined to these five different possibilities
for the value of divisions specification sources.
