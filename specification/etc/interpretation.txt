There are indefinitely many ways to interpret any segment.
This version of the code implements the following interpretation regime:

    score:
        1. time signatures on a segment-by-segment basis
    voices:
        2. divisions
        3. rhythm
    arbitrary contexts:
        4. pitch-classes, pitch, marks
        
This means that the code currently implements a rhythm-first way of building score.
Notes on this rhythm-first way of building score appear below.

(0) Interpretation enforces hierarchy on specification. Rhythmic divisions and
events always are set absolutely or else derived from segments' time signatures.
But the opposite can not obtain: time signatures may not be specified in terms of
rhythmic divisions or events. Likewise, pitch-classes, pitches and leaf attributes
apply to rhythmic events (or the structures that create them). But rhythmic events
may not be specified in terms of pitch-classes, pitches or leaf attributes.

(1) Segments' score-order matters. Score specification comprises zero or more 
segment specifications. Segment specifications' score-order is taken to be
the order in which they will notate in the finished score.

(2) Score interpretation proceeds as a series of one or more passes over every 
score segment. Call these left-to-right (score) passes, for further reference.

(3) Because relative references play a crucial role in score specification,
segment interpretation proceeds only as far as is 'resolvable' for each segment.
The first nonresolvable setting encountered during segment interpretation 
causes interpretation to pass to the next segment in score.

(4) Segment resolvability refers to which of the four broadly structured segment 
interpretation steps is reachable during the interpretation of any segment in score.
For example, if segment time signatures resolve then interpretation proceeds to 
the resolution of rhythmic divisions for each segment voice. But if segment time 
signatures do not resolve then interpretation passes to the next segment in score.

(5) What causes settings to resolve? All settings are classified as either absolute
or relative. Absolute settings comprise an absolute source. All absolute settings resolve
directly with no need to consult other settings made anywhere else in score. Relative
settings are made with reference to either another setting or to a statal server.
Whether or not any given relative setting resolves can only be determined by further
inspection of the setting's source. Examples follow.

(6) Suppose interpretation has arrived at the determination of pitch-classes for 
segment T, that only pitch-class setting N has
been found for segment T, and that N specifies the timewise determination of pitch-classes
for all pitch-carriers in T according to statal pitch-class server PCS. We know that the
rhythm of all pitch-carriers in T has been determined because we have arrived at
pitch-classes determination. And we know and are able to access the source from which
the pitch-classes in T are to be applied. So should interpretation apply pitch-classes
to all pitch-carriers in T or not? Put another way, should interpretation read from
and thereby advance the state of statal server PCS or not?

(7) The question asks about the assumptions we make of statal servers. We can only 
answer the question with further reference to location of T in S. So let us suppose
further that S comprises four segments T1, T2, T3, T4 and that our segment T equals
T4 in S. If interpretation of T4 finds that N specifies PCS for the pitch-class
application of all pitch-carriers in T4, should PCS be read? There are a number of
different ways to model this, all of which will probably eventually require implementation.
But in the current version of the system we will chose to implement a 'chronologically strict'
interpretation of the statal servers in S. That is, we must distinguish two statal server
accessor types and pile restrictions on one of the two.

(8) We may distinguish statal server access that is 'absolute' from that that is 'cursor-relative'.
In fact it is increasingly clear that what is really required is a model of arbitrarily many
cursors k0, ..., kn open against statal server W. If we designate the kn by arbitrary (possibly 
numeric) label then we need extend the implementation of W with only a dictionary of the zero or 
more kn, each equal to a (cyclic) integer offset in W. This then percolates up to specification 
and demands that statal server specification always be accompanied by either the designation of
one of the kn in W or else by an indication of an 'absolute' read (from) W. Specification of
absolute read from W comprises (cyclic) integer offset in W together with optional read direction.
Note that the interfaces to absolute and cursor-relative requests match: optional (cyclic)
integer offset together with optional read direction. The only difference between the two
is whether the offset of last read is stored in the persistent namespace of the interpreted
context(s) or not.

(9) We return to the specification of PCS in T4. Whether PCS is to be read on any particular
visit to T4 depends on the type of read specified against PCS. Absolute reads will always
be made directly: such reads are made against the server and the data served with no
consequences in changges to server state and no new information to persist in any namespace;
absolute reads happen with no further impact to the state of interpretation, as though they
never took place at all.

(10) But whether or not a a cursor-relative read should proceed is trickier to determine.
If T4 is to read from PCS then we need to know two further sets of information about PCS:
first, whether PCS is specified to be read in any of T1, T2, T3; and second, whether
PCS already has been read everywhere that is specified to be read. In other words, the 
specification of cursor-relative read against statal server W demands that we first
know whether W is in the right state to be read.

(11) How do we know if PCS is in the right state for cursor-relative read in T4?
We examine the segments T1, T2, T3 that precede T4 in score order. We inspect 
each of T1, T2, T3 for the presence of cursor-relative read against PCS.
If every cursor-relative read against PCS in T1, T2, T3 has been made (or, equivalently,
if T1, T2, T3 make no cursor-relative reads against PCS) then T4 may cursor-read PCS.

(12) The same holds for all statal server cursor-reads.

(13) What if T4 contains a pitch-class setting made relative to a selection elsewhere in S?
In this case we allow a single lookup. What will pitch-class setting N in T4 look like
if N specifies pitch-class information to be taken from elsewhere in S? N will specify
the a 'start component' somewhere in S together with the combination of a list of one or
more source context names from which to read, together with an optional read direction.
For example, N might specify to timewise forward-read pitch-classes in the violin voice
and cello voice of T2, starting from pitch-carrier 0 the violin voice of T2.
Or, N might specify to backward-read pitch-classes in the horn voice of T1, starting
from the last pitch-carrier in T1. When such a situation obtains we may say that N
provides 'score-relative' specification of pitch-classes in T4.

(14) Setting are either manifest, server-positioned, cursor-relative or score-relative.

                                             * * *

Example 1. Suppose S comprises segments T1, T2, T3, T4. We interpret S by finding the
time signatures of T1, T2, T3, T4. We start at T1 and ask what time signature setting
exists for T1. Some time signature setting must exist for T1 or else T1 can not interpret.
Suppose we find that T1 contains a setting N1 that specifies time signatures cursor-relative
to time signature server TSS1. This is a good thing and we now hope that N1 is resolvable
and that T1 contains no further time signature settings. Suppose that we check and find
that, indeed, T1 contains no further time signature settings. Now we must determine whether
N1 resolves. Because N1 is cursor-relative to TSS1, we must check to see whether any of
the segments that precede T1 contain a setting that specifies a cursor-relative read against
TSS1. Since there are no segments that precede T1 in S, this step is trivial and we find
that TSS1 is in the correct state to be read here in T1. We return to N1 and examine the
count argument given in the statal server request specified as the source of N1. Suppose
that the statal server requested specified as the source of N1 specifies a count of 10
time signatures. Since TSS1 is in the correct state to be read in N1, we call the statal
server request against TSS1 and receive a reference to the 10 time signatures TSS1 returns.
We now set these 10 time signatures as the time signatures of T1. This determines the
total (relative) duration of T1. To complete the time interpretation of T1 we must now
mark N1 as complete so that segments T2, T3, T4 will be able to determine that the statal
server request N1 contains has been made. So we mark N1 as complete. Then we must reexamine
N1 and find out whether or not N1 is marked persistent. If N1 is not marked persistent we
have nothing left to do; on the other hand, if N1 is marked persistent then we must add
the source of N1 to the global setting reservoir for use by future segments.
Suppose that N1 is marked persistent. Then what part of the source of N1 do we add
to the global setting reservoir? The source of N1 is a statal server request that
specified the forward-read of 10 time signatures from TSS1. We should probably add this
entire statal server request to the global setting reservoir; future segments will
then be able to specify at least three different things with respect to this statal
server request that was specified as the source of N1: future segments may replay
the statal server request exactly (and be handed back the next 10 time signatures in TSS1
in the forward direction); or future segments may make use of only the fact that the 
statal server request specifies TSS1 and then combine TSS1 wiht a request for a different 
number of time signatures to be taken either forward or backward from the current offset in TSS1;
or future segments may reset the current offset in TSS1 (and accept the next 10 or previous 10
time signatures in TSS1 from this new offset in TSS1); or future segments may reset
the current offset in TSS1 and specify a totally new number time signatures from TSS1, either
forward or backward. In other words, after interpreting making the cursor-relative read
for 10 time signatures against TSS1 specified in N1, the setting reservoir will contain
a segment-level entry for time signature-determination set equal to offset 10 of TSS1 in
the forward direction. Future segments may specify the reuse of all, some or none of the 
parameters of this segment-level setting for time signature-determination. Because N1 is
marked as persistent we add a segment-level entry for time signature-determination to the
setting reservoir set equal to offset 10 of TSS1 in the forward direction.

Interpretation advances and we begin the time signature interpretation of T2.
We ask what time signature setting exists for T2 and find that exactly one setting, N2,
specifies the time signatures for T2. The source specified in N2 will be either manifest, 
server-positioned, cursor-relative or score-relative. Suppose N2 specifies a time signature
source for T2 score-relative to T4. We are not yet able to resolve this score-relative
scoure of T2 because the time signatures for T4 do not yet exist. Interpreation passes
because we can not resolve the source of N2.

Interpretation advances and we check to see whether the time signatures of T3
have been determined. We find that the time signatures of T3 have not been determined
and so we ask what time signature settings exist for T3. Suppose we find that no time
signature settings exist in T3. We check the setting reservoir to see if any segment-level
time signature setting persists. (The setting reservoir implements a get_settings() method.)
We find that the setting reservoir contains a segment-level setting that set time signatures
equal to a statal server call of the next 10 time signatures from TSS1 in the forward direction.
Because we have no setting in T3 to specify otherwise (nor to augment the time signature setting
retrieved from the persistent settings reservoir) we consider replaying the time signature setting
retrieved from the persistent settings reservoir exactly. In order to do this we must check
to see whether the time signature setting retrieved from the persistent settings reservoir is
in the right state to be called. We do this by examining the segments T1, T2 prior to T3
and checking to see whether T1, T2 contain *pending* settings that specify cursor-relative
calls against TSS1. We iterate the settings of T1, T2 and find that no *pending* settings
that specify cursor-relative calls against TSS1 exist. This means that our cursor against TSS1
is in the right state to be called in T3. We call our cursor against TSS1 and receive the
next 10 time signatures from TSS1. We set these as the time signatures of T3 and we leave
this statal server request specifying the next 10 forward time signatures from TSS1 in
the persistent settings reservoir. (We do this in part because no setting found in T3 tells
us to remove any time signature setting from the persistent settings reservoir.)
The time signature interpretation of T3 is complete.

Interpretation advances and we find that the time signatures of T4 have not yet been determined.
We find that setting N3 in T4 sets the time signatures of T4 equal to the next 2 time signatures
from whatever time signature server persists in the persistent setting reservoir. We interrogate
the persistent setting reservoir and find the segment-level time signature setting that
specifies offset 20 of TSS1 read in the forward direction. We check T1, T2, T3 to see if TSS1 is
in the right state to be read in T4 and find that TSS1 is indeed in the right state to be read
in T4. We read the next two time signatures from TSS1 and set these equal to the time signatures
of T4. We then reexamine the source of N3 to see whether the interpretation of N3 should persist.
If we find that the interpretation of N3 should not persist then we are done; on the other hand, 
if we find that the interpretation of N3 should persist then we must modify the segment-level
time signature setting in the persistent setting reservoir and update that setting to reflect
offset 22 or TSS1 read 2 time signatures at a time in the forward direction.

T2 remains in the list of time signature-uninterpreted segments. So interpretation advances
from T4 to T2, passing over T1. We begin to interpret the time signatures for T2 anew.
We find that T2 contains setting N2 that specifies time signatures score-relative to T4.
We check and find that T4 has been time signature-interpreted. So we copy T4's 2 time 
signatures to T2. We reexamine N2 to find whether N2 is marked persistent.
(Note that it is an open question whether or not score-relative settings may be marked persistent.)
Here we will suppose that N2 is not marked persistent. This means that we do not need to
adjust the setting reservoir. We remove T2 from the list of time signature-uninterpreted segments.

The list of time signature-uninterpreted segments in S is empty.

The time signature interpretation of S is now complete.

                                             * * *

Example 2. Suppose S equals T1, T2, T3, T4, T5, T6.

Interpretation begin. We add T1, ..., T6 to the list of time signature-uninterpreted segments in S.

Interpretation advances to the first segment, T1, in the list of time signature-uninterpreted
segments in S. We find that T1 contains setting T1n1 that sets the time signatures of T1
manifestly to [(2, 8), (2, 8), (2, 8)]. We set the time signatures of T1 to [(2, 8), (2, 8), (2, 8)].
T1n1 is set at the segment-level and is set to persist. So we clear the setting reservoir of
any time signature settings made at the segment level. (The setting reservoir implements
a remove_settings() method. The setting reservoir implements an add_setting() method.) This
call to remove settings from the persistent settings reservoir does nothing because the
settings reservoir currently contains no settings. We then make a 'resolved copy' of T1n1
and add the resolved copy of T1n1 to the persistent settings reservoir. We mark T1n1 as complete
and remove T1 from the list of time signature-uninterpreted segments in S.

Interpretation advances to the next segment in the list of time signature-uninterpreted segments in S.
This is T2. We find that T2 contains setting T2n1 that sets the time signatures of T2 manifestly
to [(3, 8), (3, 8), (3, 8)] and we set the time signatures of T2 accordingly. Because T2n1 is set 
to persist at the segment level we remove any segment-level time signature settings from the
setting reservoir and add a resolved copy of T2n1 to the setting reservoir. We mark T2n1 as complete
and remove T2 from the list of time signature-uninterpreted segments in S.

Interpretation advances to the next segment in the list of time signature-uninterpreted segments in S.
This is T3. We find that T3 contains setting T3n1 that sets the time signatures of T3 manifestly
to [(4, 8), (4, 8), (4, 8)] and we set the time signatures of T3 accordingly. Because T3n1 is set
to persist at the segment level we remove any segment-level time signature settings from the setting
reservoir and add a resolved copy of T3n1 to the setting reservoir. We mark T3n1 as complete
and remove T3 from the list of time signature-uninterpreted segments in S.

Interpretation advances to the next segment in the list of time signature-uninterpreted segments in S.
This is T4. We find that T4 contains setting T4n1 that sets the time signatures of T4 score-relative 
to the first 7 segment-level time signatures starting from offset 0 in T1. We check to see if we
can resolve this setting and indeed we can. The first 7 segment-level time signatures starting
from T1 time signature 0 are [(2, 8), (2, 8), (2, 8), (3, 8), (3, 8), (3, 8), (4, 8)]. And so we
set these 7 time signatures as the source of time signatures to use for T4. Does T4n1 specify
a way to read this time signature source? We find that T4n1 specifies the first 11 values from
this list of 7 time signatures, read forward from offset 0. So we set the time signatures of T4
to [(2, 8), (2, 8), (2, 8), (3, 8), (3, 8), (3, 8), (4, 8), (2, 8), (2, 8), (2, 8), (3, 8)].
(We have effectively created a temporary statal server and read from it.) We then check T4n1
and find that T4n1 is not set to persist. So we discard this temporary statal server, leave
the setting reservoir unchanged, mark T4n1 as complete, and remove T4 from the list of time
signature-uninterpreted segments in S.

Interpretation advances to the next segment in the list of time signature-uninterpreted segments in S.
This is T5. We find no setting in the T5 that specifies time signatures. We consult the setting
reservoir and find the resolved version of T3n1. The resolved version of T3n1 gives
[(4, 8), (4, 8), (4, 8)] and so we set the time signatures of T5 accordingly. Since we found
no setting in T5 that specifies time signatures, remove T5 from the list of time signature-
uninterpreted segments in S and leave everything else the same.

Interpretation advances to the next segment in the list of time signature-uninterpreted segments in S.
This is T6. We find that T6 contains setting T6n1 that sets the time signatures of T6 score-relative
to the first 5 time signatures of T2 read forward from time signature 0 in T2. This is resolves
to [(3, 8), (3, 8), (3, 8), (3, 8), (3, 8)] and we set the time signatures of T6 accordingly.
Because T6n1 is not marked to persist we mark T6n1 as complete and remove T6 from the list of
time signature-uninterpreted segments in S.

The list of time signature-uninterpreted segments in S is empty.

The time signature interpretation of S is now complete.

                                             * * *

The interpretation of rhythmic divisions in S.

The interpretation of the rhythmic divisions in S begins only after the time signature interpretation
of S completes. The interpretation of the rhythmic divisions in S proceeds on a voice-by-voice
basis in S.

Interpretation begins by building a list of every division-uninterpreted setting in S.
